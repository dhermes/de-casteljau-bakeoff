#!python
#cython: boundscheck=False, wraparound=False, language_level=3
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is a generated file.

import numpy as np
from numpy cimport ndarray as ndarray_t


cdef extern void {{ env("PREFIX") }}_do1(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_do2(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_do3(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_forall1(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_forall2(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_forall3(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_serial(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_spread1(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_spread2(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_spread3(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_vs_algorithm32(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_vs_algorithm53(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)
cdef extern void {{ env("PREFIX") }}_vs_algorithm64(
    const int* num_nodes, const int* dimension, const double* nodes,
    const int* num_vals, const double* s_vals, double* evaluated)


def do1(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_do1(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def do2(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_do2(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def do3(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_do3(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def forall1(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_forall1(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def forall2(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_forall2(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def forall3(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_forall3(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def serial(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_serial(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def spread1(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_spread1(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def spread2(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_spread2(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def spread3(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_spread3(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def vs_algorithm32(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_vs_algorithm32(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def vs_algorithm53(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_vs_algorithm53(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated


def vs_algorithm64(double[::1, :] nodes, double[::1] s_vals):
    cdef int num_nodes, dimension, num_vals
    cdef ndarray_t[double, ndim=2, mode="fortran"] evaluated

    dimension, num_nodes = np.shape(nodes)
    num_vals, = np.shape(s_vals)
    evaluated = np.empty((dimension, num_vals), order="F")
    {{ env("PREFIX") }}_vs_algorithm64(
        &num_nodes,
        &dimension,
        &nodes[0, 0],
        &num_vals,
        &s_vals[0],
        &evaluated[0, 0],
    )
    return evaluated
